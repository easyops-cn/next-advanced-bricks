import path from "node:path";
import { spawn } from "node:child_process";
import { readFile, writeFile, readdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { parse } from "@babel/parser";
import babelGenerator from "@babel/generator";
import * as t from "@babel/types";
import babelTraverse from "@babel/traverse";
import { babel } from "./babel.js";
import { transpile } from "./transpile.js";

const { default: traverse } = babelTraverse;
const { default: generate } = babelGenerator;

start();

function start() {
  const task = spawn(babel, [
    "src",
    "--out-dir",
    "temp",
    "--ignore",
    "*",
    "--copy-files",
    "--delete-dir-on-start",
    "--watch"
  ]);

  task.stdout.on("data", async (data) => {
    const out = String(data);
    console.log(out);
    if (out.includes("Successfully compiled ")) {
      try {
        await processFunctions();
        await processExpressions();
      } catch (e) {
        console.error("Transpile failed:", e);
        return;
      }

      transpile();
    }
  });

  task.stderr.on('data', (data) => {
    console.error(`${data}`);
  });

  task.on('close', (code) => {
    console.log(`Transpile exited with code ${code}`);
  });
}

async function processFunctions() {
  const functionsIndexJsPath = path.resolve("temp/resources/functions/index.js");
  if (!existsSync(functionsIndexJsPath)) {
    return;
  }
  const content = await readFile(functionsIndexJsPath, "utf-8");
  const ast = parse(content, { sourceType: "module" });
  const importsMap = new Map();
  const functions = new Set();
  traverse(ast, {
    ImportDeclaration({ node }) {
      for (const specifier of node.specifiers) {
        if (specifier.type === "ImportDefaultSpecifier") {
          importsMap.set(specifier.local.name, node.source.value);
        }
      }
    },
    ExportDefaultDeclaration({ node }) {
      if (node.declaration.type === "ObjectExpression") {
        for (const prop of node.declaration.properties) {
          if (prop.value.type === "Identifier") {
            functions.add(prop.value.name);
          }
        }
      }
    }
  });

  if (functions.size === 0) {
    return;
  }

  const statements = [
    t.importDeclaration(
      [t.importSpecifier(t.identifier("loadFunction"), t.identifier("loadFunction"))],
      t.stringLiteral("jsx")
    ),

    t.exportDefaultDeclaration(
      t.objectExpression(
        [...functions].map(
          (fn) => t.objectProperty(
            t.identifier(fn),
            t.callExpression(
              t.identifier("loadFunction"),
              [
                t.stringLiteral(importsMap.get(fn)),
                t.memberExpression(
                  t.memberExpression(
                    t.identifier("import"),
                    t.identifier("meta"),
                  ),
                  t.identifier("url"),
                )
              ]
            )
          )
        )
      )
    )
  ];

  const { code } = generate(t.program(statements, undefined, "module"));

  await writeFile(functionsIndexJsPath, code);
}

function processExpressions() {
  return Promise.all([
    processExpressionsInFile("temp/routes.jsx"),
    processExpressionsInDir("temp/views", true),
    processExpressionsInDir("temp/components", true),
    processExpressionsInDir("temp/resources/menus"),
  ]);
}

async function processExpressionsInFile(filePath, processCssAsWell) {
  const isJsx = filePath.endsWith(".jsx");
  const plugins = isJsx ? ["jsx"] : [];
  const content = await readFile(filePath, "utf-8");

  const hasCss = isJsx && processCssAsWell && /\.css['"]/.test(content);

  const ast = parse(content, { plugins, sourceType: "module" });
  let transformed = false;
  let importedCss = false;
  let jsxImportDeclaration;
  let hasLoadStyleText = false;
  traverse(ast, {
    enter(path) {
      switch (path.node.type) {
        case "ObjectProperty":
        case "StringLiteral":
        case "NumericLiteral":
        case "BooleanLiteral":
        case "NullLiteral":
          return;
      }

      if (
        t.isJSX(path.node) ||
        !t.isExpression(path.node) ||
        // For identifiers, ignore `undefined` and non-computed property keys
        (path.node.type === "Identifier" && (
          path.node.name === "undefined" || (
            path.key === "key" && path.parent.type === "ObjectProperty" && !path.parent.computed
          ) ||
          path.parent.type === "ImportSpecifier" ||
          path.parent.type === "ImportDefaultSpecifier" ||
          (/^[a-z_0-9]+$/.test([path.node.name]) && !["_", "moment", "location"].includes(path.node.name))
        )) ||
        (path.node.type === "ObjectExpression" && path.node.properties.every(p => p.type === "ObjectProperty")) ||
        (path.node.type === "ArrayExpression" && path.node.elements.every(e => e.type !== "SpreadElement"))
      ) {
        return;
      }

      const exprSource = `<% ${content.substring(path.node.start, path.node.end)} %>`;
      path.replaceWith(t.stringLiteral(exprSource));
      transformed = true;
    },
    ImportDeclaration(path) {
      if (!hasCss) {
        return;
      }
      if (path.node.source.value === "jsx") {
        for (const specifier of path.node.specifiers) {
          if (
            specifier.type === "ImportSpecifier" &&
            specifier.local.name === "loadStyleText" &&
            specifier.imported.type === "Identifier" &&
            specifier.imported.name === "loadStyleText"
          ) {
            hasLoadStyleText = true;
          }
        }
      }
      if (path.node.source.value.startsWith(".") && path.node.source.value.endsWith(".css")) {
        const defaultSpecifier = path.node.specifiers.find(spec => spec.type === "ImportDefaultSpecifier");
        if (defaultSpecifier) {
          const varDeclaration = t.variableDeclaration("const", [
            t.variableDeclarator(
              defaultSpecifier.local,
              t.callExpression(
                t.identifier("loadStyleText"),
                [
                  path.node.source,
                  t.memberExpression(
                    t.memberExpression(
                      t.identifier("import"),
                      t.identifier("meta"),
                    ),
                    t.identifier("url"),
                  )
                ]
              )
            )
          ]);
          path.replaceWith(varDeclaration);
          transformed = true;
          importedCss = true;
        }
      }
    },
    // CallExpression(path) {
    //   if (importedExpr && path.node.callee.type === "Identifier" && path.node.callee.name === "use") {
    //     const { arguments: args} = path.node;
    //     if (args.length === 0) {
    //       throw new Error("`use()` should always have at least one argument");
    //     }
    //     let flag = "";
    //     let index = 0;
    //     if (args.length > 1 && args[0].type === "StringLiteral" && (args[0].value === "=" || args[0].value === "~")) {
    //       flag = args[0].value;
    //       index = 1;
    //     }
    //     const arrow = args[index];
    //     if (arrow.type !== "ArrowFunctionExpression" || arrow.body.type === "BlockStatement") {
    //       throw new Error("`use()` should pass a arrow function which return an expression");
    //     }
    //     const exprSource =  `<%${flag} ${content.substring(arrow.body.start, arrow.body.end)} %>`;
    //     path.replaceWith(t.stringLiteral(exprSource));
    //     transformed = true;
    //   }
    // }
  });

  if (!transformed) {
    return;
  }

  if (importedCss) {
    if (jsxImportDeclaration) {
      if (!hasLoadStyleText) {
        jsxImportDeclaration.specifiers.push(
          t.importSpecifier(t.identifier("loadStyleText"), t.identifier("loadStyleText"))
        );
      }
    } else {
      ast.program.body.unshift(
        t.importDeclaration([
          t.importSpecifier(t.identifier("loadStyleText"), t.identifier("loadStyleText"))
        ], t.stringLiteral("jsx"))
      );
    }
  }

  const { code } = generate(ast, {
    jsescOption: {
      minimal: true
    },
    comments: false,
  });
  await writeFile(filePath, code);
}

async function processExpressionsInDir(dir, processCssAsWell) {
  const items = await readdir(dir, { withFileTypes: true });
  return Promise.all(
    items.map(async (item) => {
      if (item.isFile()) {
        if (/\.jsx?$/.test(item.name)) {
          const filePath = path.join(dir, item.name);
          await processExpressionsInFile(filePath, processCssAsWell);
        }
      } else if (item.isDirectory()) {
        await processExpressionsInDir(path.join(dir, item.name), processCssAsWell);
      }
    })
  );
}
